---
component_title: "Transaction"
description: "The Vector `transaction` transform accepts and outputs `log` events allowing you to reduce events of a matching transaction into a single event."
event_types: ["log"]
issues_url: https://github.com/timberio/vector/issues?q=is%3Aopen+is%3Aissue+label%3A%22transform%3A+transaction%22
min_version: null
service_name: "Transaction"
sidebar_label: "transaction|[\"log\"]"
source_url: https://github.com/timberio/vector/tree/master/src/transforms/transaction.rs
status: "beta"
title: "Transaction Transform"
---

The Vector `transaction` transform accepts and [outputs `log` events](#output) allowing you to reduce events of a matching transaction into a single event.

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/docs/reference/transforms/transaction.md.erb
-->

## Configuration

import Tabs from '@theme/Tabs';

<Tabs
  block={true}
  defaultValue="common"
  values={[{"label":"Common","value":"common"},{"label":"Advanced","value":"advanced"}]}>

import TabItem from '@theme/TabItem';

<TabItem value="common">

import CodeHeader from '@site/src/components/CodeHeader';

<CodeHeader fileName="vector.toml" learnMoreUrl="/docs/setup/configuration/"/ >

```toml
[transforms.my_transform_id]
  # REQUIRED - General
  type = "transaction" # must be: "transaction"
  inputs = ["my-source-id"] # example

  # OPTIONAL - General
  identifier_fields = [] # default

  # OPTIONAL - Ends when
  [transforms.my_transform_id.ends_when]
    # REQUIRED
    type = "check_fields" # example

    # OPTIONAL
    "message.eq" = "this is the content to match against"
    "host.exists" = true
    "method.neq" = "POST"
```

</TabItem>
<TabItem value="advanced">

<CodeHeader fileName="vector.toml" learnMoreUrl="/docs/setup/configuration/"/ >

```toml
[transforms.my_transform_id]
  # REQUIRED - General
  type = "transaction" # must be: "transaction"
  inputs = ["my-source-id"] # example

  # OPTIONAL - General
  expire_after_ms = 30000 # default
  flush_period_ms = 1000 # default
  identifier_fields = [] # default

  # OPTIONAL - Ends when
  [transforms.my_transform_id.ends_when]
    # REQUIRED
    type = "check_fields" # example

    # OPTIONAL
    "message.eq" = "this is the content to match against"
    "host.exists" = true
    "method.neq" = "POST"

  # OPTIONAL - Merge strategies
  [transforms.my_transform_id.merge_strategies]
    `<field_name>` = "array" # example, enum
```

</TabItem>
</Tabs>

## Options

import Fields from '@site/src/components/Fields';

import Field from '@site/src/components/Field';

<Fields filters={true}>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"ends_when"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"table"}
  unit={null}
  >

### ends_when

A condition used to distinguish the final event of a transaction. If this condition resolves to true for an event the transaction it belongs to is immediately flushed.

<Fields filters={false}>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.eq":"this is the content to match against"}]}
  groups={[]}
  name={"`<field_name>`.eq"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  >

#### `<field_name>`.eq

Check whether a fields contents exactly matches the value specified.


</Field>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"host.exists":true}]}
  groups={[]}
  name={"`<field_name>`.exists"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"bool"}
  unit={null}
  >

#### `<field_name>`.exists

Check whether a field exists or does not exist, depending on the provided valuebeing `true` or `false` respectively.


</Field>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"method.neq":"POST"}]}
  groups={[]}
  name={"`<field_name>`.neq"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  >

#### `<field_name>`.neq

Check whether a fields contents does not match the value specified.


</Field>


<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={["check_fields","is_log","is_metric"]}
  groups={[]}
  name={"type"}
  path={"ends_when"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  >

#### type

The type of the condition to execute.


</Field>


</Fields>

</Field>


<Field
  common={false}
  defaultValue={30000}
  enumValues={null}
  examples={[30000]}
  groups={[]}
  name={"expire_after_ms"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"int"}
  unit={null}
  >

### expire_after_ms

A maximum period of time to wait before a transaction should be considered complete after not having received another event.


</Field>


<Field
  common={false}
  defaultValue={1000}
  enumValues={null}
  examples={[1000]}
  groups={[]}
  name={"flush_period_ms"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"int"}
  unit={null}
  >

### flush_period_ms

Controls the frequency that Vector checks for (and flushes) expired transactions.


</Field>


<Field
  common={true}
  defaultValue={[]}
  enumValues={null}
  examples={[["request_id"],["user_id","transaction_id"]]}
  groups={[]}
  name={"identifier_fields"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"[string]"}
  unit={null}
  >

### identifier_fields

An ordered list of fields to distinguish transactions by. Each transaction has a separate event combining state, and these fields should be used to prevent
events from unrelated transactions from combining.


</Field>


<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message":"append","username":"append"}]}
  groups={[]}
  name={"merge_strategies"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"table"}
  unit={null}
  >

### merge_strategies

A map of field names to custom merge strategies. For each field specified this strategy will be used for combining events rather than the default behavior.

The default behavior is as follows:

1. The first value of a string field is kept, subsequent values are discarded.
2. For timestamp fields the first is kept and a new field `<field_name>_end` is
   added with the last received timestamp value.
3. Numeric values are added.

<Fields filters={false}>


<Field
  common={true}
  defaultValue={null}
  enumValues={{"array":"Each value is appended to an array.","append":"Append each string value (delimited with a space).","discard":"Discard all but the first value found.","sum":"Sum all number values."}}
  examples={["array","append","discard","sum"]}
  groups={[]}
  name={"`<field_name>`"}
  path={"merge_strategies"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  >

#### `<field_name>`

The custom merge strategy to use for a field.


</Field>


</Fields>

</Field>


</Fields>

## Output

The `transaction` transform accepts and [outputs `log` events](#output) allowing you to reduce events of a matching transaction into a single event.
For example:


<Tabs
  block={true}
  defaultValue="default"
  values={[{"label":"Default","value":"default"},{"label":"With Identifier Fields","value":"with-identifier-fields"}]}>

<TabItem value="default">

Given the following configuration:

<CodeHeader fileName="vector.toml" />

```toml
[transforms.transaction_events]
  type = "transaction"
  inputs = [...]
```

And these three [`log` events][docs.data-model.log]:

<CodeHeader fileName="first log event" />

```javascript
{
  "message": "A thing is happening",
  "custom_string_field_1": "value1",
  "this_much": 1
}
```

Followed by:

<CodeHeader fileName="second log event" />

```javascript
{
  "message": "That thing is still happening",
  "custom_string_field_2": "value2",
  "this_much": 3
}
```

And, finally:

<CodeHeader fileName="third log event" />

```javascript
{
  "message": "That thing is concluded",
  "custom_string_field_3": "value3",
  "this_much": 2
}
```

A single log event will eventually be produced:

```javascript
{
  "message": "A thing is happening",
  "custom_string_field_1": "value1",
  "custom_string_field_2": "value2",
  "custom_string_field_3": "value3",
  "this_much": 6
}
```

Notice that string values have not been overridden and integer values have been summed.

</TabItem>

<TabItem value="with-identifier-fields">

Given the following configuration:

<CodeHeader fileName="vector.toml" />

```toml
[transforms.transaction_events]
  type = "transaction"
  inputs = [...]

  identifier_fields = ["request_id"]

  [transforms.transaction_events.merge_strategies]
    request_action = "array"

  [transforms.transaction_events.ends_when]
    "request_concluded.exists" = true
```

And these three [`log` events][docs.data-model.log]:

<CodeHeader fileName="first log event" />

```javascript
{
  "message": "A thing is happening",
  "request_id": "1",
  "request_action": "start",
  "this_much": 1
}
```

Followed by:

<CodeHeader fileName="second log event" />

```javascript
{
  "message": "That thing is still happening",
  "request_id": "1",
  "request_action": "bounced",
  "this_much": 2
}
```

And:

<CodeHeader fileName="third log event" />

```javascript
{
  "message": "A different thing is happening",
  "request_id": "2",
  "request_action": "start",
  "this_much": 5
}
```

And, finally:

<CodeHeader fileName="fourth log event" />

```javascript
{
  "message": "That thing concluded",
  "request_id": "1",
  "request_action": "rebound",
  "request_concluded": true,
  "this_much": 3
}
```

A single log event will be produced and flushed immediately:

```javascript
{
  "message": "A thing is happening",
  "request_id": "1",
  "request_action": ["start","bounced","rebound"]
  "request_concluded": true,
  "this_much": 6
}
```

Notice that the fields from the third event are not present as it has been identified as a separate transaction and will be aggregated separately. Also, the values of the field `request_action` have been stored in an array instead of the default behavior.

</TabItem>
</Tabs>

## How It Works

### Environment Variables

Environment variables are supported through all of Vector's configuration.
Simply add `${MY_ENV_VAR}` in your Vector configuration file and the variable
will be replaced before being evaluated.

You can learn more in the [Environment Variables][docs.configuration#environment-variables]
section.

### When to use this transform

Where possible, Vector will handle event merging at the source level. For
example, the [`file`][docs.sources.file] contains a `message_start_indicator`
option and the [`docker`][docs.sources.file] contains an `auto_partial_merge`
option. Both of these options should be used instead of this transform.
Unfortunately, merging logs is not always this straight forward. It is
precisely these edge cases that this transform hopes to solve.

If you're using this transform for a common use case, please consider
[opening an issue][urls.new_feature_request] to let us know.


[docs.configuration#environment-variables]: /docs/setup/configuration/#environment-variables
[docs.data-model.log]: /docs/about/data-model/log/
[docs.sources.file]: /docs/reference/sources/file/
[urls.new_feature_request]: https://github.com/timberio/vector/issues/new?labels=type%3A+new+feature
